--[[
    SWIFT - A Modern Roblox UI Library
    Created with love for Roblox developers
    Features: Animations, Responsiveness, Material Design
    AUTHER--Ist5208\u2764\ufe0f\u2764\ufe0f\u2764\ufe0f


FIXED VERSION - Critical issues resolved

]]


local Swift = {}
Swift.__index = Swift
Swift.Version = "1.0.1"


-- Configuration
local Config = {
    DefaultFont = Enum.Font.GothamBold,
    DefaultTextSize = 14,
    DefaultCornerRadius = 8,
    AnimationSpeed = 0.3,
    DefaultTheme = "dark",
    Padding = 8,
}


-- Color Palettes
local Themes = {
    dark = {
        background = Color3.fromRGB(30, 30, 30),
        surface = Color3.fromRGB(45, 45, 45),
        primary = Color3.fromRGB(66, 135, 245),
        accent = Color3.fromRGB(255, 107, 107),
        text = Color3.fromRGB(255, 255, 255),
        textSecondary = Color3.fromRGB(180, 180, 180),
        border = Color3.fromRGB(70, 70, 70),
        success = Color3.fromRGB(76, 175, 80),
        warning = Color3.fromRGB(255, 193, 7),
        error = Color3.fromRGB(244, 67, 54),
    },
    light = {
        background = Color3.fromRGB(245, 245, 245),
        surface = Color3.fromRGB(255, 255, 255),
        primary = Color3.fromRGB(33, 150, 243),
        accent = Color3.fromRGB(233, 30, 99),
        text = Color3.fromRGB(33, 33, 33),
        textSecondary = Color3.fromRGB(117, 117, 117),
        border = Color3.fromRGB(189, 189, 189),
        success = Color3.fromRGB(76, 175, 80),
        warning = Color3.fromRGB(255, 193, 7),
        error = Color3.fromRGB(244, 67, 54),
    }
}


-- Utility Functions
local function lerp(a, b, t)
    return a + (b - a) * t
end


local function lerpColor(c1, c2, t)
    return Color3.new(lerp(c1.R, c2.R, t), lerp(c1.G, c2.G, t), lerp(c1.B, c2.B, t))
end


local function createFrame(parent, name)
    local frame = Instance.new("Frame")
    frame.Name = name
    frame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    frame.BorderSizePixel = 0
    frame.Parent = parent
    return frame
end


local function createTextLabel(parent, name, text)
    local label = Instance.new("TextLabel")
    label.Name = name
    label.Text = text
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.Font = Config.DefaultFont
    label.TextSize = Config.DefaultTextSize
    label.Parent = parent
    return label
end


local function createTextButton(parent, name, text)
    local button = Instance.new("TextButton")
    button.Name = name
    button.Text = text
    button.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.Font = Config.DefaultFont
    button.TextSize = Config.DefaultTextSize
    button.BorderSizePixel = 0
    button.Parent = parent
    return button
end


local function applyCornerRadius(obj, radius)
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, radius)
    corner.Parent = obj
    return corner
end


local function applyPadding(obj, padding)
    local pad = Instance.new("UIPadding")
    pad.PaddingTop = UDim.new(0, padding)
    pad.PaddingBottom = UDim.new(0, padding)
    pad.PaddingLeft = UDim.new(0, padding)
    pad.PaddingRight = UDim.new(0, padding)
    pad.Parent = obj
    return pad
end


local function applyListLayout(obj, direction, padding)
    local layout = Instance.new("UIListLayout")
    layout.FillDirection = direction or Enum.FillDirection.Vertical
    layout.Padding = UDim.new(0, padding or Config.Padding)
    layout.SortOrder = Enum.SortOrder.LayoutOrder
    layout.Parent = obj
    return layout
end


local function animate(obj, properties, duration, easingStyle)
    duration = duration or Config.AnimationSpeed
    easingStyle = easingStyle or Enum.EasingStyle.Quad
    local tweenInfo = TweenInfo.new(duration, easingStyle, Enum.EasingDirection.InOut)
    local tween = game:GetService("TweenService"):Create(obj, tweenInfo, properties)
    tween:Play()
    return tween
end


-- Validation Functions
local function validateTheme(themeName)
    if not Themes[themeName] then
        warn("Swift: Theme '" .. themeName .. "' not found. Using default theme.")
        return Config.DefaultTheme
    end
    return themeName
end


local function validateCallback(callback)
    if callback and type(callback) ~= "function" then
        warn("Swift: Callback must be a function")
        return nil
    end
    return callback
end


-- Main Window Class
local Window = {}
Window.__index = Window


function Window.new(title, options)
    options = options or {}
    local self = setmetatable({}, Window)


self.Title = title or "Swift Window"
self.Theme = validateTheme(options.theme or Config.DefaultTheme)
self.Colors = Themes[self.Theme]
self.Draggable = options.draggable ~= false
self.Size = options.size or UDim2.new(0, 500, 0, 600)
self.Position = options.position or UDim2.new(0.5, -250, 0.5, -300)
self.Connections = {}

self:CreateUI()
return self

end


function Window:CreateUI()
    -- Main Window Frame
    self.Frame = createFrame(game:GetService("CoreGui"), "SwiftWindow")
    self.Frame.Size = self.Size
    self.Frame.Position = self.Position
    self.Frame.BackgroundColor3 = self.Colors.surface
    applyCornerRadius(self.Frame, Config.DefaultCornerRadius)


-- Title Bar
self.TitleBar = createFrame(self.Frame, "TitleBar")
self.TitleBar.Size = UDim2.new(1, 0, 0, 40)
self.TitleBar.Position = UDim2.new(0, 0, 0, 0)
self.TitleBar.BackgroundColor3 = self.Colors.primary
applyCornerRadius(self.TitleBar, Config.DefaultCornerRadius)

-- Title Text
self.TitleLabel = createTextLabel(self.TitleBar, "TitleLabel", self.Title)
self.TitleLabel.Size = UDim2.new(1, -40, 1, 0)
self.TitleLabel.TextXAlignment = Enum.TextXAlignment.Left
applyPadding(self.TitleLabel, 12)

-- Close Button
self.CloseButton = createTextButton(self.TitleBar, "CloseButton", "\u00d7")
self.CloseButton.Size = UDim2.new(0, 40, 1, 0)
self.CloseButton.Position = UDim2.new(1, -40, 0, 0)
self.CloseButton.BackgroundColor3 = self.Colors.accent
self.CloseButton.TextSize = 24
self.CloseButton.MouseButton1Click:Connect(function()
    self:Close()
end)

-- Content Container
self.ContentFrame = createFrame(self.Frame, "ContentFrame")
self.ContentFrame.Size = UDim2.new(1, 0, 1, -40)
self.ContentFrame.Position = UDim2.new(0, 0, 0, 40)
self.ContentFrame.BackgroundColor3 = self.Colors.surface
self.ContentFrame.BackgroundTransparency = 0

applyListLayout(self.ContentFrame, Enum.FillDirection.Vertical, Config.Padding)
applyPadding(self.ContentFrame, Config.Padding)

-- Setup dragging
if self.Draggable then
    self:SetupDragging()
end

-- Show animation
self.Frame.Size = UDim2.new(self.Size.X.Scale, self.Size.X.Offset, 0, 0)
animate(self.Frame, {Size = self.Size}, 0.4)

end


function Window:SetupDragging()
    local UserInputService = game:GetService("UserInputService")
    local dragging = false
    local dragStartPos = Vector2.new(0, 0)
    local frameStartPos = Vector2.new(0, 0)


local dragStartConnection = self.TitleBar.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStartPos = Vector2.new(input.Position.X, input.Position.Y)
        frameStartPos = Vector2.new(self.Frame.AbsolutePosition.X, self.Frame.AbsolutePosition.Y)
    end
end)

local dragEndConnection = self.TitleBar.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = false
    end
end)

local dragMoveConnection = UserInputService.InputChanged:Connect(function(input)
    if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
        local mousePos = Vector2.new(input.Position.X, input.Position.Y)
        local delta = mousePos - dragStartPos
        self.Frame.Position = UDim2.new(0, frameStartPos.X + delta.X, 0, frameStartPos.Y + delta.Y)
    end
end)

table.insert(self.Connections, dragStartConnection)
table.insert(self.Connections, dragEndConnection)
table.insert(self.Connections, dragMoveConnection)

end


function Window:Close()
    -- Clean up connections
    for _, connection in ipairs(self.Connections) do
        if connection then
            connection:Disconnect()
        end
    end


animate(self.Frame, {Size = UDim2.new(self.Size.X.Scale, self.Size.X.Offset, 0, 0)}, 0.3, Enum.EasingStyle.Back)
game:GetService("Debris"):AddItem(self.Frame, 0.4)

end


function Window:SetTheme(themeName)
    local newTheme = validateTheme(themeName)
    if newTheme ~= self.Theme then
        self.Theme = newTheme
        self.Colors = Themes[self.Theme]
        self.TitleBar.BackgroundColor3 = self.Colors.primary
        self.ContentFrame.BackgroundColor3 = self.Colors.surface
        self.Frame.BackgroundColor3 = self.Colors.surface
    end
end


-- Button Class
local Button = {}
Button.__index = Button


function Button.new(parent, text, callback, options)
    options = options or {}
    local self = setmetatable({}, Button)


self.Text = text or "Button"
self.Callback = validateCallback(callback)
self.Parent = parent
self.Colors = parent.Colors
self.Hovered = false

self:CreateUI(options)
return self

end


function Button:CreateUI(options)
    self.Frame = createFrame(self.Parent.ContentFrame, "Button")
    self.Frame.Size = UDim2.new(1, -Config.Padding * 2, 0, 40)
    self.Frame.BackgroundColor3 = self.Colors.primary
    self.Frame.LayoutOrder = options.order or 0
    applyCornerRadius(self.Frame, 6)


self.Button = createTextButton(self.Frame, "TextButton", self.Text)
self.Button.Size = UDim2.new(1, 0, 1, 0)
self.Button.BackgroundTransparency = 1
self.Button.TextColor3 = Color3.fromRGB(255, 255, 255)

self.Button.MouseEnter:Connect(function()
    self.Hovered = true
    animate(self.Frame, {BackgroundColor3 = self.Colors.accent}, 0.2)
end)

self.Button.MouseLeave:Connect(function()
    self.Hovered = false
    animate(self.Frame, {BackgroundColor3 = self.Colors.primary}, 0.2)
end)

self.Button.MouseButton1Click:Connect(function()
    -- Scale animation on click
    local originalSize = self.Frame.Size
    animate(self.Frame, {Size = UDim2.new(originalSize.X.Scale, originalSize.X.Offset * 0.98, originalSize.Y.Scale, originalSize.Y.Offset)}, 0.1)
    task.wait(0.1)
    animate(self.Frame, {Size = originalSize}, 0.1)
    
    if self.Callback then
        local success, errorMsg = pcall(self.Callback)
        if not success then
            warn("Swift: Button callback error: " .. tostring(errorMsg))
        end
    end
end)

end


-- Label Class
local Label = {}
Label.__index = Label


function Label.new(parent, text, options)
    options = options or {}
    local self = setmetatable({}, Label)


self.Text = text or "Label"
self.Parent = parent
self.Colors = parent.Colors

self:CreateUI(options)
return self

end


function Label:CreateUI(options)
    self.Frame = createFrame(self.Parent.ContentFrame, "Label")
    self.Frame.Size = UDim2.new(1, -Config.Padding * 2, 0, 20) -- Fixed "auto" issue
    self.Frame.BackgroundTransparency = 1
    self.Frame.LayoutOrder = options.order or 0


self.TextLabel = createTextLabel(self.Frame, "TextLabel", self.Text)
self.TextLabel.Size = UDim2.new(1, 0, 1, 0)
self.TextLabel.TextColor3 = options.color or self.Colors.text
self.TextLabel.TextXAlignment = options.alignment or Enum.TextXAlignment.Left
self.TextLabel.Font = options.font or Config.DefaultFont
self.TextLabel.TextSize = options.textSize or Config.DefaultTextSize

-- Auto-resize based on text content
self.TextLabel:GetPropertyChangedSignal("TextBounds"):Connect(function()
    local textHeight = self.TextLabel.TextBounds.Y
    self.Frame.Size = UDim2.new(1, -Config.Padding * 2, 0, math.max(20, textHeight + 4))
end)

end


function Label:SetText(text)
    self.Text = text or ""
    self.TextLabel.Text = self.Text
end


-- TextBox Class
local TextBox = {}
TextBox.__index = TextBox


function TextBox.new(parent, placeholder, callback, options)
    options = options or {}
    local self = setmetatable({}, TextBox)


self.Placeholder = placeholder or "Enter text..."
self.Callback = validateCallback(callback)
self.Parent = parent
self.Colors = parent.Colors
self.Value = ""

self:CreateUI(options)
return self

end


function TextBox:CreateUI(options)
    self.Frame = createFrame(self.Parent.ContentFrame, "TextBox")
    self.Frame.Size = UDim2.new(1, -Config.Padding * 2, 0, 40)
    self.Frame.BackgroundColor3 = self.Colors.surface
    self.Frame.BorderColor3 = self.Colors.border
    self.Frame.BorderSizePixel = 1
    self.Frame.LayoutOrder = options.order or 0
    applyCornerRadius(self.Frame, 6)
    applyPadding(self.Frame, 8)


self.Input = Instance.new("TextBox")
self.Input.Name = "Input"
self.Input.Size = UDim2.new(1, 0, 1, 0)
self.Input.BackgroundTransparency = 1
self.Input.TextColor3 = self.Colors.text
self.Input.PlaceholderColor3 = self.Colors.textSecondary
self.Input.PlaceholderText = self.Placeholder
self.Input.Font = Config.DefaultFont
self.Input.TextSize = Config.DefaultTextSize
self.Input.Parent = self.Frame

self.Input.FocusLost:Connect(function()
    self.Value = self.Input.Text
    if self.Callback then
        local success, errorMsg = pcall(self.Callback, self.Value)
        if not success then
            warn("Swift: TextBox callback error: " .. tostring(errorMsg))
        end
    end
    animate(self.Frame, {BorderColor3 = self.Colors.border}, 0.2)
end)

self.Input.Focused:Connect(function()
    animate(self.Frame, {BorderColor3 = self.Colors.primary}, 0.2)
end)

end


function TextBox:GetValue()
    return self.Input.Text
end


function TextBox:SetValue(text)
    self.Input.Text = text or ""
    self.Value = self.Input.Text
end


-- Checkbox Class
local Checkbox = {}
Checkbox.__index = Checkbox


function Checkbox.new(parent, label, defaultValue, callback, options)
    options = options or {}
    local self = setmetatable({}, Checkbox)


self.Label = label or "Checkbox"
self.Value = defaultValue or false
self.Callback = validateCallback(callback)
self.Parent = parent
self.Colors = parent.Colors

self:CreateUI(options)
return self

end


function Checkbox:CreateUI(options)
    self.Frame = createFrame(self.Parent.ContentFrame, "Checkbox")
    self.Frame.Size = UDim2.new(1, -Config.Padding * 2, 0, 30)
    self.Frame.BackgroundTransparency = 1
    self.Frame.LayoutOrder = options.order or 0


-- Checkbox box
self.Box = createFrame(self.Frame, "Box")
self.Box.Size = UDim2.new(0, 20, 0, 20)
self.Box.Position = UDim2.new(0, 0, 0.5, -10)
self.Box.BackgroundColor3 = self.Value and self.Colors.primary or self.Colors.surface
self.Box.BorderColor3 = self.Colors.border
self.Box.BorderSizePixel = 1
applyCornerRadius(self.Box, 4)

-- Checkmark
self.Checkmark = createTextLabel(self.Box, "Checkmark", "\u2713")
self.Checkmark.Size = UDim2.new(1, 0, 1, 0)
self.Checkmark.TextColor3 = Color3.fromRGB(255, 255, 255)
self.Checkmark.TextSize = 16
self.Checkmark.Visible = self.Value

-- Label
self.LabelText = createTextLabel(self.Frame, "Label", self.Label)
self.LabelText.Size = UDim2.new(1, -30, 1, 0)
self.LabelText.Position = UDim2.new(0, 30, 0, 0)
self.LabelText.TextXAlignment = Enum.TextXAlignment.Left
self.LabelText.TextColor3 = self.Colors.text

-- Click detection
local clickArea = Instance.new("TextButton")
clickArea.Name = "ClickArea"
clickArea.Size = UDim2.new(1, 0, 1, 0)
clickArea.BackgroundTransparency = 1
clickArea.Text = ""
clickArea.Parent = self.Frame

clickArea.MouseButton1Click:Connect(function()
    self:Toggle()
end)

end


function Checkbox:Toggle()
    self.Value = not self.Value
    animate(self.Box, {BackgroundColor3 = self.Value and self.Colors.primary or self.Colors.surface}, 0.2)
    self.Checkmark.Visible = self.Value


if self.Callback then
    local success, errorMsg = pcall(self.Callback, self.Value)
    if not success then
        warn("Swift: Checkbox callback error: " .. tostring(errorMsg))
    end
end

end


function Checkbox:GetValue()
    return self.Value
end


function Checkbox:SetValue(value)
    self.Value = value or false
    self.Box.BackgroundColor3 = self.Value and self.Colors.primary or self.Colors.surface
    self.Checkmark.Visible = self.Value
end


-- Slider Class
local Slider = {}
Slider.__index = Slider


function Slider.new(parent, label, min, max, default, callback, options)
    options = options or {}
    local self = setmetatable({}, Slider)


self.Label = label or "Slider"
self.Min = min or 0
self.Max = max or 100
self.Value = math.clamp(default or min, min, max)
self.Callback = validateCallback(callback)
self.Parent = parent
self.Colors = parent.Colors
self.Dragging = false

self:CreateUI(options)
return self

end


function Slider:CreateUI(options)
    self.Frame = createFrame(self.Parent.ContentFrame, "Slider")
    self.Frame.Size = UDim2.new(1, -Config.Padding * 2, 0, 60)
    self.Frame.BackgroundTransparency = 1
    self.Frame.LayoutOrder = options.order or 0


-- Label
self.LabelText = createTextLabel(self.Frame, "Label", self.Label)
self.LabelText.Size = UDim2.new(1, 0, 0, 20)
self.LabelText.TextXAlignment = Enum.TextXAlignment.Left
self.LabelText.TextColor3 = self.Colors.text

-- Value display
self.ValueLabel = createTextLabel(self.Frame, "Value", tostring(self.Value))
self.ValueLabel.Size = UDim2.new(0.3, 0, 0, 20)
self.ValueLabel.Position = UDim2.new(0.7, 0, 0, 0)
self.ValueLabel.TextXAlignment = Enum.TextXAlignment.Right
self.ValueLabel.TextColor3 = self.Colors.primary

-- Slider background
self.SliderBg = createFrame(self.Frame, "Background")
self.SliderBg.Size = UDim2.new(1, 0, 0, 4)
self.SliderBg.Position = UDim2.new(0, 0, 0.5, 8)
self.SliderBg.BackgroundColor3 = self.Colors.border
applyCornerRadius(self.SliderBg, 2)

-- Slider fill
self.SliderFill = createFrame(self.SliderBg, "Fill")
local percentage = (self.Value - self.Min) / (self.Max - self.Min)
self.SliderFill.Size = UDim2.new(percentage, 0, 1, 0)
self.SliderFill.BackgroundColor3 = self.Colors.primary
self.SliderFill.BorderSizePixel = 0
applyCornerRadius(self.SliderFill, 2)

-- Slider thumb
self.Thumb = createFrame(self.SliderBg, "Thumb")
self.Thumb.Size = UDim2.new(0, 16, 0, 16)
self.Thumb.Position = UDim2.new(percentage, -8, 0.5, -8)
self.Thumb.BackgroundColor3 = self.Colors.primary
applyCornerRadius(self.Thumb, 8)

-- Slider interactions
self.Thumb.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        self.Dragging = true
    end
end)

self.Thumb.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        self.Dragging = false
    end
end)

self.InputChangedConnection = game:GetService("UserInputService").InputChanged:Connect(function(input)
    if self.Dragging then
        self:UpdateSliderPosition()
    end
end)

self.SliderBg.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        self:UpdateSliderPosition()
    end
end)

end


function Slider:UpdateSliderPosition()
    local mouse = game:GetService("Players").LocalPlayer:GetMouse()
    local sliderX = self.SliderBg.AbsolutePosition.X
    local sliderSize = self.SliderBg.AbsoluteSize.X
    local mouseX = mouse.X


local percentage = math.clamp((mouseX - sliderX) / sliderSize, 0, 1)
self.Value = math.floor(self.Min + (self.Max - self.Min) * percentage)

self.Thumb.Position = UDim2.new(percentage, -8, 0.5, -8)
self.SliderFill.Size = UDim2.new(percentage, 0, 1, 0)
self.ValueLabel.Text = tostring(self.Value)

if self.Callback then
    local success, errorMsg = pcall(self.Callback, self.Value)
    if not success then
        warn("Swift: Slider callback error: " .. tostring(errorMsg))
    end
end

end


function Slider:GetValue()
    return self.Value
end


function Slider:SetValue(value)
    self.Value = math.clamp(value, self.Min, self.Max)
    local percentage = (self.Value - self.Min) / (self.Max - self.Min)
    self.Thumb.Position = UDim2.new(percentage, -8, 0.5, -8)
    self.SliderFill.Size = UDim2.new(percentage, 0, 1, 0)
    self.ValueLabel.Text = tostring(self.Value)
end


function Slider:Destroy()
    if self.InputChangedConnection then
        self.InputChangedConnection:Disconnect()
    end
end


-- Dropdown Class
local Dropdown = {}
Dropdown.__index = Dropdown


function Dropdown.new(parent, label, options, callback, defaultIndex)
    local self = setmetatable({}, Dropdown)


self.Label = label or "Dropdown"
self.Options = options or {}
self.Callback = validateCallback(callback)
self.Parent = parent
self.Colors = parent.Colors
self.Selected = math.clamp(defaultIndex or 1, 1, #self.Options > 0 and #self.Options or 1)
self.Open = false

self:CreateUI()
return self

end


function Dropdown:CreateUI()
    self.Frame = createFrame(self.Parent.ContentFrame, "Dropdown")
    self.Frame.Size = UDim2.new(1, -Config.Padding * 2, 0, 40)
    self.Frame.BackgroundColor3 = self.Colors.surface
    self.Frame.BorderColor3 = self.Colors.border
    self.Frame.BorderSizePixel = 1
    applyCornerRadius(self.Frame, 6)


-- Main button
local selectedText = #self.Options > 0 and self.Options[self.Selected] or "No options"
self.Button = createTextButton(self.Frame, "Button", selectedText .. " \u25bc")
self.Button.Size = UDim2.new(1, 0, 1, 0)
self.Button.BackgroundTransparency = 1
self.Button.TextColor3 = self.Colors.text

self.Button.MouseButton1Click:Connect(function()
    self:Toggle()
end)

-- Dropdown menu
self.Menu = createFrame(self.Frame, "Menu")
local menuHeight = math.min(#self.Options * 35, 200) -- Limit max height
self.Menu.Size = UDim2.new(1, 0, 0, 0)
self.Menu.Position = UDim2.new(0, 0, 1, 2)
self.Menu.BackgroundColor3 = self.Colors.surface
self.Menu.BorderColor3 = self.Colors.border
self.Menu.BorderSizePixel = 1
self.Menu.ZIndex = 10
self.Menu.Visible = false
applyCornerRadius(self.Menu, 6)

applyListLayout(self.Menu, Enum.FillDirection.Vertical, 0)

-- Create option buttons
for i, option in ipairs(self.Options) do
    local optButton = createTextButton(self.Menu, "Option" .. i, option)
    optButton.Size = UDim2.new(1, 0, 0, 35)
    optButton.BackgroundColor3 = self.Colors.surface
    optButton.TextColor3 = self.Colors.text
    optButton.Parent = self.Menu
    optButton.ZIndex = 11
    
    optButton.MouseEnter:Connect(function()
        animate(optButton, {BackgroundColor3 = self.Colors.primary}, 0.15)
    end)
    
    optButton.MouseLeave:Connect(function()
        animate(optButton, {BackgroundColor3 = self.Colors.surface}, 0.15)
    end)
    
    optButton.MouseButton1Click:Connect(function()
        self.Selected = i
        self.Button.Text = option .. " \u25bc"
        self:Toggle()
        if self.Callback then
            local success, errorMsg = pcall(self.Callback, option, i)
            if not success then
                warn("Swift: Dropdown callback error: " .. tostring(errorMsg))
            end
        end
    end)
end

end


function Dropdown:Toggle()
    self.Open = not self.Open
    self.Menu.Visible = self.Open


if self.Open then
    local menuHeight = math.min(#self.Options * 35, 200)
    animate(self.Menu, {Size = UDim2.new(1, 0, 0, menuHeight)}, 0.2)
else
    animate(self.Menu, {Size = UDim2.new(1, 0, 0, 0)}, 0.2)
end

end


function Dropdown:GetSelected()
    if #self.Options > 0 then
        return self.Options[self.Selected], self.Selected
    end
    return nil, 0
end


function Dropdown:SetSelected(index)
    if index >= 1 and index <= #self.Options then
        self.Selected = index
        self.Button.Text = self.Options[index] .. " \u25bc"
    end
end


-- Tab Class
local Tab = {}
Tab.__index = Tab


function Tab.new(parent, name, options)
    options = options or {}
    local self = setmetatable({}, Tab)


self.Name = name or "Tab"
self.Parent = parent
self.Colors = parent.Colors
self.Active = options.active or false
self.Elements = {}
self.Order = options.order or 0

self:CreateUI()
return self

end


function Tab:CreateUI()
    -- Tab button
    self.Button = createTextButton(self.Parent.TabBar, "TabButton", self.Name)
    self.Button.Size = UDim2.new(0, 120, 1, 0)
    self.Button.BackgroundColor3 = self.Active and self.Colors.primary or self.Colors.surface
    self.Button.TextColor3 = self.Colors.text
    self.Button.BorderSizePixel = 0
    self.Button.LayoutOrder = self.Order


self.Button.MouseButton1Click:Connect(function()
    self.Parent:SelectTab(self)
end)

-- Tab content
self.ContentFrame = createFrame(self.Parent.Frame, "TabContent")
self.ContentFrame.Size = UDim2.new(1, 0, 1, -80)
self.ContentFrame.Position = UDim2.new(0, 0, 0, 80)
self.ContentFrame.BackgroundColor3 = self.Colors.surface
self.ContentFrame.Visible = self.Active

applyListLayout(self.ContentFrame, Enum.FillDirection.Vertical, Config.Padding)
applyPadding(self.ContentFrame, Config.Padding)

end


function Tab:Select()
    self.Active = true
    self.ContentFrame.Visible = true
    animate(self.Button, {BackgroundColor3 = self.Colors.primary}, 0.2)
end


function Tab:Deselect()
    self.Active = false
    self.ContentFrame.Visible = false
    animate(self.Button, {BackgroundColor3 = self.Colors.surface}, 0.2)
end


-- TabWindow Class
local TabWindow = {}
TabWindow.__index = TabWindow


function TabWindow.new(title, options)
    options = options or {}
    local self = setmetatable({}, TabWindow)


self.Title = title or "Swift TabWindow"
self.Theme = validateTheme(options.theme or Config.DefaultTheme)
self.Colors = Themes[self.Theme]
self.Draggable = options.draggable ~= false
self.Size = options.size or UDim2.new(0, 600, 0, 700)
self.Position = options.position or UDim2.new(0.5, -300, 0.5, -350)
self.Tabs = {}
self.ActiveTab = nil
self.Connections = {}

self:CreateUI()
return self

end


function TabWindow:CreateUI()
    -- Main Frame
    self.Frame = createFrame(game:GetService("CoreGui"), "SwiftTabWindow")
    self.Frame.Size = self.Size
    self.Frame.Position = self.Position
    self.Frame.BackgroundColor3 = self.Colors.surface
    applyCornerRadius(self.Frame, Config.DefaultCornerRadius)


-- Title Bar
self.TitleBar = createFrame(self.Frame, "TitleBar")
self.TitleBar.Size = UDim2.new(1, 0, 0, 40)
self.TitleBar.BackgroundColor3 = self.Colors.primary
applyCornerRadius(self.TitleBar, Config.DefaultCornerRadius)

self.TitleLabel = createTextLabel(self.TitleBar, "Title", self.Title)
self.TitleLabel.Size = UDim2.new(1, -40, 1, 0)
self.TitleLabel.TextXAlignment = Enum.TextXAlignment.Left
applyPadding(self.TitleLabel, 12)

-- Close Button
self.CloseButton = createTextButton(self.TitleBar, "CloseButton", "\u00d7")
self.CloseButton.Size = UDim2.new(0, 40, 1, 0)
self.CloseButton.Position = UDim2.new(1, -40, 0, 0)
self.CloseButton.BackgroundColor3 = self.Colors.accent
self.CloseButton.TextSize = 24
self.CloseButton.MouseButton1Click:Connect(function()
    self:Close()
end)

-- Tab Bar
self.TabBar = createFrame(self.Frame, "TabBar")
self.TabBar.Size = UDim2.new(1, 0, 0, 40)
self.TabBar.Position = UDim2.new(0, 0, 0, 40)
self.TabBar.BackgroundColor3 = self.Colors.surface
applyListLayout(self.TabBar, Enum.FillDirection.Horizontal, 0)

-- Setup dragging
if self.Draggable then
    self:SetupDragging()
end

self.Frame.Size = UDim2.new(self.Size.X.Scale, self.Size.X.Offset, 0, 0)
animate(self.Frame, {Size = self.Size}, 0.4)

end


function TabWindow:SetupDragging()
    local UserInputService = game:GetService("UserInputService")
    local dragging = false
    local dragStartPos = Vector2.new(0, 0)
    local frameStartPos = Vector2.new(0, 0)


local dragStartConnection = self.TitleBar.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStartPos = Vector2.new(input.Position.X, input.Position.Y)
        frameStartPos = Vector2.new(self.Frame.AbsolutePosition.X, self.Frame.AbsolutePosition.Y)
    end
end)

local dragEndConnection = self.TitleBar.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = false
    end
end)

local dragMoveConnection = UserInputService.InputChanged:Connect(function(input)
    if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
        local mousePos = Vector2.new(input.Position.X, input.Position.Y)
        local delta = mousePos - dragStartPos
        self.Frame.Position = UDim2.new(0, frameStartPos.X + delta.X, 0, frameStartPos.Y + delta.Y)
    end
end)

table.insert(self.Connections, dragStartConnection)
table.insert(self.Connections, dragEndConnection)
table.insert(self.Connections, dragMoveConnection)

end


function TabWindow:AddTab(name, options)
    options = options or {}
    local tab = Tab.new(self, name, {active = #self.Tabs == 0, order = #self.Tabs})
    table.insert(self.Tabs, tab)


if #self.Tabs == 1 then
    self.ActiveTab = tab
end

return tab

end


function TabWindow:SelectTab(tab)
    if self.ActiveTab then
        self.ActiveTab:Deselect()
    end
    self.ActiveTab = tab
    tab:Select()
end


function TabWindow:Close()
    -- Clean up connections
    for _, connection in ipairs(self.Connections) do
        if connection then
            connection:Disconnect()
        end
    end


animate(self.Frame, {Size = UDim2.new(self.Size.X.Scale, self.Size.X.Offset, 0, 0)}, 0.3, Enum.EasingStyle.Back)
game:GetService("Debris"):AddItem(self.Frame, 0.4)

end


-- Notification Class
local Notification = {}
Notification.__index = Notification


function Notification.new(title, message, notificationType, duration)
    local self = setmetatable({}, Notification)


self.Title = title or "Notification"
self.Message = message or ""
self.Type = notificationType or "info"
self.Duration = duration or 4
self.Theme = Config.DefaultTheme
self.Colors = Themes[self.Theme]

self:CreateUI()
self:AnimateIn()

return self

end


function Notification:GetTypeColor()
    if self.Type == "success" then
        return self.Colors.success
    elseif self.Type == "warning" then
        return self.Colors.warning
    elseif self.Type == "error" then
        return self.Colors.error
    else
        return self.Colors.primary
    end
end


function Notification:CreateUI()
    self.Frame = createFrame(game:GetService("CoreGui"), "Notification")
    self.Frame.Size = UDim2.new(0, 350, 0, 100)
    -- Position from bottom-right corner with proper screen bounds checking
    local screenSize = game:GetService("GuiService"):GetScreenResolution()
    self.Frame.Position = UDim2.new(1, -370, 1, -120)
    self.Frame.BackgroundColor3 = self.Colors.surface
    self.Frame.BorderColor3 = self:GetTypeColor()
    self.Frame.BorderSizePixel = 2
    applyCornerRadius(self.Frame, Config.DefaultCornerRadius)
    applyPadding(self.Frame, 12)


-- Icon area
local iconText = self.Type == "success" and "\u2713" or 
                 self.Type == "warning" and "\u26a0" or 
                 self.Type == "error" and "\u2715" or "\u2139"
self.Icon = createTextLabel(self.Frame, "Icon", iconText)
self.Icon.Size = UDim2.new(0, 40, 1, 0)
self.Icon.TextColor3 = self:GetTypeColor()
self.Icon.TextSize = 24

-- Content
local contentFrame = createFrame(self.Frame, "Content")
contentFrame.Size = UDim2.new(1, -50, 1, 0)
contentFrame.Position = UDim2.new(0, 45, 0, 0)
contentFrame.BackgroundTransparency = 1
applyListLayout(contentFrame, Enum.FillDirection.Vertical, 2)

-- Title
self.TitleLabel = createTextLabel(contentFrame, "Title", self.Title)
self.TitleLabel.Size = UDim2.new(1, 0, 0, 20)
self.TitleLabel.TextXAlignment = Enum.TextXAlignment.Left
self.TitleLabel.TextColor3 = self.Colors.text
self.TitleLabel.Font = Enum.Font.GothamBold
self.TitleLabel.TextSize = 14

-- Message
self.MessageLabel = createTextLabel(contentFrame, "Message", self.Message)
self.MessageLabel.Size = UDim2.new(1, 0, 0, 50)
self.MessageLabel.TextXAlignment = Enum.TextXAlignment.Left
self.MessageLabel.TextYAlignment = Enum.TextYAlignment.Top
self.MessageLabel.TextColor3 = self.Colors.textSecondary
self.MessageLabel.TextWrapped = true
self.MessageLabel.TextSize = 12

end


function Notification:AnimateIn()
    local startPos = UDim2.new(1, 20, 1, -120)
    local endPos = UDim2.new(1, -370, 1, -120)


self.Frame.Position = startPos
animate(self.Frame, {Position = endPos}, 0.4, Enum.EasingStyle.Quad)

task.spawn(function()
    task.wait(self.Duration)
    animate(self.Frame, {Position = startPos}, 0.4, Enum.EasingStyle.Quad)
    task.wait(0.5)
    if self.Frame then
        self.Frame:Destroy()
    end
end)

end


-- ToggleButton Class
local ToggleButton = {}
ToggleButton.__index = ToggleButton


function ToggleButton.new(parent, label, defaultValue, callback, options)
    options = options or {}
    local self = setmetatable({}, ToggleButton)


self.Label = label or "Toggle"
self.Value = defaultValue or false
self.Callback = validateCallback(callback)
self.Parent = parent
self.Colors = parent.Colors

self:CreateUI(options)
return self

end


function ToggleButton:CreateUI(options)
    self.Frame = createFrame(self.Parent.ContentFrame, "ToggleButton")
    self.Frame.Size = UDim2.new(1, -Config.Padding * 2, 0, 40)
    self.Frame.BackgroundTransparency = 1
    self.Frame.LayoutOrder = options.order or 0


-- Label
self.LabelText = createTextLabel(self.Frame, "Label", self.Label)
self.LabelText.Size = UDim2.new(1, -60, 1, 0)
self.LabelText.TextXAlignment = Enum.TextXAlignment.Left
self.LabelText.TextColor3 = self.Colors.text

-- Toggle background
self.ToggleBg = createFrame(self.Frame, "Background")
self.ToggleBg.Size = UDim2.new(0, 50, 0, 28)
self.ToggleBg.Position = UDim2.new(1, -50, 0.5, -14)
self.ToggleBg.BackgroundColor3 = self.Value and self.Colors.primary or self.Colors.border
applyCornerRadius(self.ToggleBg, 14)

-- Toggle circle
self.Circle = createFrame(self.ToggleBg, "Circle")
self.Circle.Size = UDim2.new(0, 24, 0, 24)
self.Circle.Position = UDim2.new(self.Value and 0.5 or 0, self.Value and -2 or 2, 0.5, -12)
self.Circle.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
applyCornerRadius(self.Circle, 12)

-- Click detection
local clickArea = Instance.new("TextButton")
clickArea.Name = "ClickArea"
clickArea.Size = UDim2.new(1, 0, 1, 0)
clickArea.BackgroundTransparency = 1
clickArea.Text = ""
clickArea.Parent = self.Frame

clickArea.MouseButton1Click:Connect(function()
    self:Toggle()
end)

end


function ToggleButton:Toggle()
    self.Value = not self.Value
    local targetBg = self.Value and self.Colors.primary or self.Colors.border
    local targetPos = UDim2.new(self.Value and 0.5 or 0, self.Value and -2 or 2, 0.5, -12)


animate(self.ToggleBg, {BackgroundColor3 = targetBg}, 0.3)
animate(self.Circle, {Position = targetPos}, 0.3)

if self.Callback then
    local success, errorMsg = pcall(self.Callback, self.Value)
    if not success then
        warn("Swift: ToggleButton callback error: " .. tostring(errorMsg))
    end
end

end


function ToggleButton:GetValue()
    return self.Value
end


function ToggleButton:SetValue(value)
    self.Value = value or false
    self.ToggleBg.BackgroundColor3 = self.Value and self.Colors.primary or self.Colors.border
    self.Circle.Position = UDim2.new(self.Value and 0.5 or 0, self.Value and -2 or 2, 0.5, -12)
end


-- ColorPicker Class
local ColorPicker = {}
ColorPicker.__index = ColorPicker


function ColorPicker.new(parent, label, defaultColor, callback, options)
    options = options or {}
    local self = setmetatable({}, ColorPicker)


self.Label = label or "Color"
self.Color = defaultColor or Color3.fromRGB(255, 0, 0)
self.Callback = validateCallback(callback)
self.Parent = parent
self.Colors = parent.Colors
self.Open = false
self.PickerFrame = nil

self:CreateUI(options)
return self

end


function ColorPicker:CreateUI(options)
    self.Frame = createFrame(self.Parent.ContentFrame, "ColorPicker")
    self.Frame.Size = UDim2.new(1, -Config.Padding * 2, 0, 80)
    self.Frame.BackgroundTransparency = 1
    self.Frame.LayoutOrder = options.order or 0


-- Label
self.LabelText = createTextLabel(self.Frame, "Label", self.Label)
self.LabelText.Size = UDim2.new(1, 0, 0, 20)
self.LabelText.TextXAlignment = Enum.TextXAlignment.Left
self.LabelText.TextColor3 = self.Colors.text

-- Color display button
self.ColorButton = createFrame(self.Frame, "ColorButton")
self.ColorButton.Size = UDim2.new(0, 40, 0, 40)
self.ColorButton.Position = UDim2.new(0, 0, 0, 25)
self.ColorButton.BackgroundColor3 = self.Color
applyCornerRadius(self.ColorButton, 6)

-- Click to open picker
local clickArea = Instance.new("TextButton")
clickArea.Name = "ClickArea"
clickArea.Size = UDim2.new(0, 100, 0, 40)
clickArea.Position = UDim2.new(0, 0, 0, 25)
clickArea.BackgroundTransparency = 1
clickArea.Text = ""
clickArea.Parent = self.Frame

clickArea.MouseButton1Click:Connect(function()
    self:OpenPicker()
end)

-- Color preview text
self.HexLabel = createTextLabel(self.Frame, "HexLabel", self:ColorToHex(self.Color))
self.HexLabel.Size = UDim2.new(0, 150, 0, 40)
self.HexLabel.Position = UDim2.new(0, 50, 0, 25)
self.HexLabel.TextXAlignment = Enum.TextXAlignment.Left
self.HexLabel.TextColor3 = self.Colors.text

end


function ColorPicker:ColorToHex(color)
    local r = math.floor(color.R * 255)
    local g = math.floor(color.G * 255)
    local b = math.floor(color.B * 255)
    return string.format("#%02X%02X%02X", r, g, b)
end


function ColorPicker:OpenPicker()
    if self.Open or self.PickerFrame then return end
    self.Open = true


self.PickerFrame = createFrame(game:GetService("CoreGui"), "ColorPickerMenu")
self.PickerFrame.Size = UDim2.new(0, 250, 0, 280)
self.PickerFrame.Position = UDim2.new(0.5, -125, 0.5, -140)
self.PickerFrame.BackgroundColor3 = self.Colors.surface
self.PickerFrame.BorderColor3 = self.Colors.border
self.PickerFrame.BorderSizePixel = 2
applyCornerRadius(self.PickerFrame, Config.DefaultCornerRadius)

-- Preset colors
local presets = {
    Color3.fromRGB(255, 0, 0), Color3.fromRGB(255, 128, 0), Color3.fromRGB(255, 255, 0),
    Color3.fromRGB(0, 255, 0), Color3.fromRGB(0, 255, 255), Color3.fromRGB(0, 0, 255),
    Color3.fromRGB(128, 0, 255), Color3.fromRGB(255, 0, 255), Color3.fromRGB(255, 255, 255),
    Color3.fromRGB(128, 128, 128), Color3.fromRGB(64, 64, 64), Color3.fromRGB(0, 0, 0)
}

-- Create preset color buttons
for i, presetColor in ipairs(presets) do
    local row = math.floor((i - 1) / 3)
    local col = (i - 1) % 3
    
    local presetButton = createFrame(self.PickerFrame, "Preset" .. i)
    presetButton.Size = UDim2.new(0, 70, 0, 40)
    presetButton.Position = UDim2.new(0, 10 + col * 75, 0, 10 + row * 45)
    presetButton.BackgroundColor3 = presetColor
    applyCornerRadius(presetButton, 4)
    
    local presetClick = Instance.new("TextButton")
    presetClick.Size = UDim2.new(1, 0, 1, 0)
    presetClick.BackgroundTransparency = 1
    presetClick.Text = ""
    presetClick.Parent = presetButton
    
    presetClick.MouseButton1Click:Connect(function()
        self:SetColor(presetColor)
        self:ClosePicker()
    end)
end

-- Close button
local closeBtn = createTextButton(self.PickerFrame, "CloseBtn", "Close")
closeBtn.Size = UDim2.new(1, -20, 0, 30)
closeBtn.Position = UDim2.new(0, 10, 0, 240)
closeBtn.BackgroundColor3 = self.Colors.primary
closeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
applyCornerRadius(closeBtn, 4)

closeBtn.MouseButton1Click:Connect(function()
    self:ClosePicker()
end)

end


function ColorPicker:ClosePicker()
    if self.PickerFrame then
        self.PickerFrame:Destroy()
        self.PickerFrame = nil
    end
    self.Open = false
end


function ColorPicker:GetColor()
    return self.Color
end


function ColorPicker:SetColor(color)
    self.Color = color
    self.ColorButton.BackgroundColor3 = color
    self.HexLabel.Text = self:ColorToHex(color)
    if self.Callback then
        local success, errorMsg = pcall(self.Callback, color)
        if not success then
            warn("Swift: ColorPicker callback error: " .. tostring(errorMsg))
        end
    end
end


function ColorPicker:Destroy()
    self:ClosePicker()
end


-- Separator/Divider Class
local Separator = {}
Separator.__index = Separator


function Separator.new(parent, options)
    options = options or {}
    local self = setmetatable({}, Separator)


self.Parent = parent
self.Colors = parent.Colors

self:CreateUI(options)
return self

end


function Separator:CreateUI(options)
    self.Frame = createFrame(self.Parent.ContentFrame, "Separator")
    self.Frame.Size = UDim2.new(1, -Config.Padding * 2, 0, 2)
    self.Frame.BackgroundColor3 = self.Colors.border
    self.Frame.BorderSizePixel = 0
    self.Frame.LayoutOrder = options.order or 0
end


-- Section/Group Class
local Section = {}
Section.__index = Section


function Section.new(parent, title, options)
    options = options or {}
    local self = setmetatable({}, Section)


self.Title = title or "Section"
self.Parent = parent
self.Colors = parent.Colors
self.Collapsed = options.collapsed or false

self:CreateUI(options)
return self

end


function Section:CreateUI(options)
    self.Frame = createFrame(self.Parent.ContentFrame, "Section")
    self.Frame.Size = UDim2.new(1, -Config.Padding * 2, 0, 30) -- Start with header height
    self.Frame.BackgroundColor3 = self.Colors.surface
    self.Frame.LayoutOrder = options.order or 0
    self.Frame.BackgroundTransparency = 1


applyListLayout(self.Frame, Enum.FillDirection.Vertical, Config.Padding)

-- Header
local headerFrame = createFrame(self.Frame, "Header")
headerFrame.Size = UDim2.new(1, 0, 0, 30)
headerFrame.BackgroundColor3 = self.Colors.surface
headerFrame.BackgroundTransparency = 1

self.TitleLabel = createTextLabel(headerFrame, "Title", self.Title)
self.TitleLabel.Size = UDim2.new(1, -30, 1, 0)
self.TitleLabel.TextXAlignment = Enum.TextXAlignment.Left
self.TitleLabel.TextColor3 = self.Colors.primary
self.TitleLabel.Font = Enum.Font.GothamBold

-- Collapse button
local collapseBtn = createTextButton(headerFrame, "CollapseBtn", self.Collapsed and "\u25b6" or "\u25bc")
collapseBtn.Size = UDim2.new(0, 30, 1, 0)
collapseBtn.Position = UDim2.new(1, -30, 0, 0)
collapseBtn.BackgroundTransparency = 1
collapseBtn.TextColor3 = self.Colors.primary

-- Content frame
self.ContentFrame = createFrame(self.Frame, "Content")
self.ContentFrame.Size = UDim2.new(1, 0, 0, 0)
self.ContentFrame.BackgroundColor3 = self.Colors.surface
self.ContentFrame.BackgroundTransparency = 1
self.ContentFrame.Visible = not self.Collapsed

applyListLayout(self.ContentFrame, Enum.FillDirection.Vertical, Config.Padding)
applyPadding(self.ContentFrame, Config.Padding)

collapseBtn.MouseButton1Click:Connect(function()
    self.Collapsed = not self.Collapsed
    self.ContentFrame.Visible = not self.Collapsed
    collapseBtn.Text = self.Collapsed and "\u25b6" or "\u25bc"
    
    -- Animate section size
    if self.Collapsed then
        animate(self.Frame, {Size = UDim2.new(1, -Config.Padding * 2, 0, 30)}, 0.2)
    else
        -- Let the content determine the height
        task.wait(0.1) -- Brief delay for content to update
        local contentHeight = 50 -- Minimum content height
        animate(self.Frame, {Size = UDim2.new(1, -Config.Padding * 2, 0, 30 + contentHeight)}, 0.2)
    end
end)

end


-- RichTextLabel Class
local RichText = {}
RichText.__index = RichText


function RichText.new(parent, text, options)
    options = options or {}
    local self = setmetatable({}, RichText)


self.Text = text or "Rich Text"
self.Parent = parent
self.Colors = parent.Colors

self:CreateUI(options)
return self

end


function RichText:CreateUI(options)
    self.Frame = createFrame(self.Parent.ContentFrame, "RichText")
    self.Frame.Size = UDim2.new(1, -Config.Padding * 2, 0, options.height or 50)
    self.Frame.BackgroundColor3 = self.Colors.surface
    self.Frame.BackgroundTransparency = 1
    self.Frame.LayoutOrder = options.order or 0


self.Label = createTextLabel(self.Frame, "TextLabel", self.Text)
self.Label.Size = UDim2.new(1, 0, 1, 0)
self.Label.TextXAlignment = options.alignment or Enum.TextXAlignment.Left
self.Label.TextYAlignment = Enum.TextYAlignment.Top
self.Label.TextColor3 = options.color or self.Colors.text
self.Label.TextWrapped = true
self.Label.TextSize = options.textSize or Config.DefaultTextSize
self.Label.Font = options.font or Config.DefaultFont
self.Label.RichText = true

end


function RichText:SetText(text)
    self.Text = text or ""
    self.Label.Text = self.Text
end


-- Input Handler Class
local InputHandler = {}
InputHandler.__index = InputHandler


function InputHandler.new()
    local self = setmetatable({}, InputHandler)
    self.KeyBinds = {}
    self.Connections = {}
    return self
end


function InputHandler:RegisterKey(keyCode, callback)
    if type(keyCode) ~= "userdata" or not keyCode.EnumType then
        warn("Swift: Invalid keyCode provided to RegisterKey")
        return
    end


local validatedCallback = validateCallback(callback)
if not validatedCallback then
    return
end

table.insert(self.KeyBinds, {key = keyCode, callback = validatedCallback})

local connection = game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == keyCode then
        local success, errorMsg = pcall(validatedCallback)
        if not success then
            warn("Swift: InputHandler callback error: " .. tostring(errorMsg))
        end
    end
end)

table.insert(self.Connections, connection)

end


function InputHandler:UnregisterKey(keyCode)
    for i, bind in ipairs(self.KeyBinds) do
        if bind.key == keyCode then
            table.remove(self.KeyBinds, i)
            if self.Connections[i] then
                self.Connections[i]:Disconnect()
                table.remove(self.Connections, i)
            end
            break
        end
    end
end


function InputHandler:Cleanup()
    for _, connection in ipairs(self.Connections) do
        if connection then
            connection:Disconnect()
        end
    end
    self.Connections = {}
    self.KeyBinds = {}
end


-- Swift API
function Swift.CreateWindow(title, options)
    return Window.new(title, options)
end


function Swift.CreateTabWindow(title, options)
    return TabWindow.new(title, options)
end


function Swift.ShowNotification(title, message, notificationType, duration)
    return Notification.new(title, message, notificationType, duration)
end


function Swift.CreateButton(parent, text, callback, options)
    return Button.new(parent, text, callback, options)
end


function Swift.CreateLabel(parent, text, options)
    return Label.new(parent, text, options)
end


function Swift.CreateTextBox(parent, placeholder, callback, options)
    return TextBox.new(parent, placeholder, callback, options)
end


function Swift.CreateCheckbox(parent, label, defaultValue, callback, options)
    return Checkbox.new(parent, label, defaultValue, callback, options)
end


function Swift.CreateSlider(parent, label, min, max, default, callback, options)
    return Slider.new(parent, label, min, max, default, callback, options)
end


function Swift.CreateDropdown(parent, label, options, callback, defaultIndex)
    return Dropdown.new(parent, label, options, callback, defaultIndex)
end


function Swift.CreateToggleButton(parent, label, defaultValue, callback, options)
    return ToggleButton.new(parent, label, defaultValue, callback, options)
end


function Swift.CreateColorPicker(parent, label, defaultColor, callback, options)
    return ColorPicker.new(parent, label, defaultColor, callback, options)
end


function Swift.CreateSeparator(parent, options)
    return Separator.new(parent, options)
end


function Swift.CreateSection(parent, title, options)
    return Section.new(parent, title, options)
end


function Swift.CreateRichText(parent, text, options)
    return RichText.new(parent, text, options)
end


function Swift.CreateInputHandler()
    return InputHandler.new()
end


function Swift.SetTheme(themeName)
    if Themes[themeName] then
        Config.DefaultTheme = themeName
    else
        warn("Swift: Theme '" .. themeName .. "' not found.")
    end
end


function Swift.GetThemes()
    local themeNames = {}
    for name, _ in pairs(Themes) do
        table.insert(themeNames, name)
    end
    return themeNames
end


function Swift.SetAnimationSpeed(speed)
    if type(speed) == "number" and speed > 0 then
        Config.AnimationSpeed = speed
    else
        warn("Swift: AnimationSpeed must be a positive number")
    end
end


function Swift.GetConfig()
    return {
        DefaultFont = Config.DefaultFont,
        DefaultTextSize = Config.DefaultTextSize,
        DefaultCornerRadius = Config.DefaultCornerRadius,
        AnimationSpeed = Config.AnimationSpeed,
        DefaultTheme = Config.DefaultTheme,
        Padding = Config.Padding,
    }
end


function Swift.SetConfig(newConfig)
    if type(newConfig) ~= "table" then
        warn("Swift: Config must be a table")
        return
    end


for key, value in pairs(newConfig) do
    if Config[key] ~= nil then
        Config[key] = value
    else
        warn("Swift: Unknown config key: " .. tostring(key))
    end
end

end


-- Export Swift
_G.Swift = Swift


return Swift
